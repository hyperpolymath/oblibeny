// SPDX-License-Identifier: MIT OR Palimpsest-0.8
// Copyright (c) 2024 Hyperpolymath

//! Code generation from OIR to Rust
//!
//! This module generates Rust code that uses the oblibeny-runtime crate
//! for ORAM operations and constant-time primitives.

use crate::error::Error;
use crate::oir::*;
use std::fmt::Write;

/// Validate that an identifier is safe for code generation
///
/// Returns an error if the identifier contains characters that could
/// enable code injection attacks.
fn validate_identifier(name: &str) -> Result<(), Error> {
    if name.is_empty() {
        return Err(Error::codegen("empty identifier"));
    }

    // First character must be letter or underscore
    let first = name.chars().next().unwrap();
    if !first.is_ascii_alphabetic() && first != '_' {
        return Err(Error::codegen(format!(
            "invalid identifier '{}': must start with letter or underscore",
            name
        )));
    }

    // Rest must be alphanumeric or underscore
    for c in name.chars() {
        if !c.is_ascii_alphanumeric() && c != '_' {
            return Err(Error::codegen(format!(
                "invalid identifier '{}': contains forbidden character '{}'",
                name, c
            )));
        }
    }

    // Check for Rust reserved keywords that could cause issues
    const DANGEROUS_NAMES: &[&str] = &[
        "unsafe", "asm", "extern", "mod", "crate", "self", "super",
        "macro_rules", "include", "include_str", "include_bytes",
    ];
    if DANGEROUS_NAMES.contains(&name) {
        return Err(Error::codegen(format!(
            "identifier '{}' is reserved and cannot be used",
            name
        )));
    }

    Ok(())
}

/// Sanitize an identifier for safe code generation
///
/// Validates and returns the identifier, or returns an error.
fn sanitize_ident(name: &str) -> Result<&str, Error> {
    validate_identifier(name)?;
    Ok(name)
}

/// Code generator state
pub struct CodeGenerator {
    indent: usize,
    output: String,
    inline_runtime: bool,
}

impl CodeGenerator {
    pub fn new() -> Self {
        CodeGenerator {
            indent: 0,
            output: String::new(),
            inline_runtime: false,
        }
    }

    pub fn set_inline_runtime(&mut self, inline: bool) {
        self.inline_runtime = inline;
    }

    /// Generate Rust code from an OIR module
    pub fn generate(&mut self, module: &Module) -> Result<String, Error> {
        self.output.clear();

        // File header
        self.emit_header(module)?;

        // Imports
        self.emit_imports()?;

        // Struct definitions
        for struct_def in &module.structs {
            self.emit_struct(struct_def)?;
        }

        // External function declarations
        for ext in &module.externs {
            self.emit_extern(ext)?;
        }

        // Function definitions
        for func in &module.functions {
            self.emit_function(func)?;
        }

        Ok(std::mem::take(&mut self.output))
    }

    fn emit_header(&mut self, module: &Module) -> Result<(), Error> {
        writeln!(self.output, "// SPDX-License-Identifier: MIT OR Palimpsest-0.8")?;
        writeln!(self.output, "// Copyright (c) 2024 Hyperpolymath")?;
        writeln!(self.output)?;
        writeln!(self.output, "//! Generated by oblibeny-backend")?;
        if let Some(name) = &module.name {
            writeln!(self.output, "//! Module: {}", name)?;
        }
        writeln!(self.output)?;
        writeln!(self.output, "#![allow(unused_variables)]")?;
        writeln!(self.output, "#![allow(dead_code)]")?;
        writeln!(self.output)?;
        Ok(())
    }

    fn emit_imports(&mut self) -> Result<(), Error> {
        if self.inline_runtime {
            // Inline the essential runtime code
            writeln!(self.output, "// Inline runtime")?;
            writeln!(self.output, "mod runtime {{")?;
            writeln!(self.output, "    pub use subtle::{{Choice, ConditionallySelectable}};")?;
            writeln!(self.output)?;
            writeln!(self.output, "    /// Constant-time conditional move")?;
            writeln!(self.output, "    #[inline]")?;
            writeln!(self.output, "    pub fn cmov<T: ConditionallySelectable>(cond: bool, a: T, b: T) -> T {{")?;
            writeln!(self.output, "        T::conditional_select(&b, &a, Choice::from(cond as u8))")?;
            writeln!(self.output, "    }}")?;
            writeln!(self.output, "}}")?;
        } else {
            writeln!(self.output, "use oblibeny_runtime::prelude::*;")?;
        }
        writeln!(self.output)?;
        Ok(())
    }

    fn emit_struct(&mut self, s: &StructDef) -> Result<(), Error> {
        writeln!(self.output, "#[derive(Debug, Clone)]")?;
        writeln!(self.output, "pub struct {} {{", s.name)?;
        self.indent += 1;
        for (name, at) in &s.fields {
            self.emit_indent()?;
            writeln!(self.output, "pub {}: {},", name, at.typ.to_rust())?;
        }
        self.indent -= 1;
        writeln!(self.output, "}}")?;
        writeln!(self.output)?;
        Ok(())
    }

    fn emit_extern(&mut self, ext: &ExternFunc) -> Result<(), Error> {
        writeln!(self.output, "extern \"C\" {{")?;
        self.indent += 1;
        self.emit_indent()?;
        write!(self.output, "fn {}(", ext.name)?;
        for (i, param) in ext.params.iter().enumerate() {
            if i > 0 {
                write!(self.output, ", ")?;
            }
            write!(self.output, "arg{}: {}", i, param.typ.to_rust())?;
        }
        writeln!(self.output, ") -> {};", ext.return_type.typ.to_rust())?;
        self.indent -= 1;
        writeln!(self.output, "}}")?;
        writeln!(self.output)?;
        Ok(())
    }

    fn emit_function(&mut self, func: &Function) -> Result<(), Error> {
        // Documentation
        if func.is_oblivious {
            writeln!(self.output, "/// Oblivious function - access patterns hide secrets")?;
        }
        if func.is_constant_time {
            writeln!(self.output, "/// Constant-time function - no secret-dependent branches")?;
        }

        // Attributes
        if func.is_constant_time {
            writeln!(self.output, "#[inline(never)]")?;
        }

        // Function signature
        write!(self.output, "pub fn {}(", func.name)?;
        for (i, (name, at)) in func.params.iter().enumerate() {
            if i > 0 {
                write!(self.output, ", ")?;
            }
            write!(self.output, "{}: {}", name, at.typ.to_rust())?;
        }
        writeln!(self.output, ") -> {} {{", func.return_type.typ.to_rust())?;

        // Function body
        self.indent += 1;
        self.emit_block(&func.body)?;
        self.indent -= 1;
        writeln!(self.output, "}}")?;
        writeln!(self.output)?;
        Ok(())
    }

    fn emit_block(&mut self, block: &Block) -> Result<(), Error> {
        for instr in block {
            self.emit_instr(instr)?;
        }
        Ok(())
    }

    fn emit_instr(&mut self, instr: &Instr) -> Result<(), Error> {
        match instr {
            Instr::Let(name, at, expr) => {
                self.emit_indent()?;
                write!(self.output, "let {}: {} = ", name, at.typ.to_rust())?;
                self.emit_expr(expr)?;
                writeln!(self.output, ";")?;
            }

            Instr::Assign(lhs, rhs) => {
                self.emit_indent()?;
                self.emit_expr(lhs)?;
                write!(self.output, " = ")?;
                self.emit_expr(rhs)?;
                writeln!(self.output, ";")?;
            }

            Instr::OramWrite(arr, idx, val) => {
                self.emit_indent()?;
                self.emit_expr(arr)?;
                write!(self.output, ".oram_write(")?;
                self.emit_expr(idx)?;
                write!(self.output, ", ")?;
                self.emit_expr(val)?;
                writeln!(self.output, ");")?;
            }

            Instr::If(cond, then_block, else_block) => {
                self.emit_indent()?;
                write!(self.output, "if ")?;
                self.emit_expr(cond)?;
                writeln!(self.output, " {{")?;
                self.indent += 1;
                self.emit_block(then_block)?;
                self.indent -= 1;
                if !else_block.is_empty() {
                    self.emit_indent()?;
                    writeln!(self.output, "}} else {{")?;
                    self.indent += 1;
                    self.emit_block(else_block)?;
                    self.indent -= 1;
                }
                self.emit_indent()?;
                writeln!(self.output, "}}")?;
            }

            Instr::While(cond, body) => {
                self.emit_indent()?;
                write!(self.output, "while ")?;
                self.emit_expr(cond)?;
                writeln!(self.output, " {{")?;
                self.indent += 1;
                self.emit_block(body)?;
                self.indent -= 1;
                self.emit_indent()?;
                writeln!(self.output, "}}")?;
            }

            Instr::For(var, start, end, body) => {
                self.emit_indent()?;
                write!(self.output, "for {} in ", var)?;
                self.emit_expr(start)?;
                write!(self.output, "..")?;
                self.emit_expr(end)?;
                writeln!(self.output, " {{")?;
                self.indent += 1;
                self.emit_block(body)?;
                self.indent -= 1;
                self.emit_indent()?;
                writeln!(self.output, "}}")?;
            }

            Instr::Return(expr) => {
                self.emit_indent()?;
                match expr {
                    Some(e) => {
                        write!(self.output, "return ")?;
                        self.emit_expr(e)?;
                        writeln!(self.output, ";")?;
                    }
                    None => {
                        writeln!(self.output, "return;")?;
                    }
                }
            }

            Instr::Expr(e) => {
                self.emit_indent()?;
                self.emit_expr(e)?;
                writeln!(self.output, ";")?;
            }
        }
        Ok(())
    }

    fn emit_expr(&mut self, expr: &Expr) -> Result<(), Error> {
        match expr {
            Expr::Lit(lit) => self.emit_literal(lit)?,

            Expr::Var(name) => {
                let safe_name = sanitize_ident(name)?;
                write!(self.output, "{}", safe_name)?;
            }

            Expr::Binop(op, lhs, rhs) => {
                write!(self.output, "(")?;
                self.emit_expr(lhs)?;
                write!(self.output, " {} ", op.to_rust())?;
                self.emit_expr(rhs)?;
                write!(self.output, ")")?;
            }

            Expr::Unop(op, operand) => {
                write!(self.output, "{}", op.to_rust())?;
                self.emit_expr(operand)?;
            }

            Expr::Call(name, args) => {
                let safe_name = sanitize_ident(name)?;
                write!(self.output, "{}(", safe_name)?;
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 {
                        write!(self.output, ", ")?;
                    }
                    self.emit_expr(arg)?;
                }
                write!(self.output, ")")?;
            }

            Expr::Index(arr, idx) => {
                self.emit_expr(arr)?;
                write!(self.output, "[")?;
                self.emit_expr(idx)?;
                write!(self.output, "]")?;
            }

            Expr::Field(obj, field) => {
                let safe_field = sanitize_ident(field)?;
                self.emit_expr(obj)?;
                write!(self.output, ".{}", safe_field)?;
            }

            Expr::Cmov(cond, then_val, else_val) => {
                if self.inline_runtime {
                    write!(self.output, "runtime::cmov(")?;
                } else {
                    write!(self.output, "cmov(")?;
                }
                self.emit_expr(cond)?;
                write!(self.output, ", ")?;
                self.emit_expr(then_val)?;
                write!(self.output, ", ")?;
                self.emit_expr(else_val)?;
                write!(self.output, ")")?;
            }

            Expr::OramRead(arr, idx) => {
                self.emit_expr(arr)?;
                write!(self.output, ".oram_read(")?;
                self.emit_expr(idx)?;
                write!(self.output, ")")?;
            }

            Expr::Struct(name, fields) => {
                let safe_name = sanitize_ident(name)?;
                write!(self.output, "{} {{", safe_name)?;
                for (i, (fname, fval)) in fields.iter().enumerate() {
                    let safe_fname = sanitize_ident(fname)?;
                    if i > 0 {
                        write!(self.output, ",")?;
                    }
                    write!(self.output, " {}: ", safe_fname)?;
                    self.emit_expr(fval)?;
                }
                write!(self.output, " }}")?;
            }
        }
        Ok(())
    }

    fn emit_literal(&mut self, lit: &Literal) -> Result<(), Error> {
        match lit {
            Literal::Int(n) => write!(self.output, "{}", n)?,
            Literal::Bool(b) => write!(self.output, "{}", b)?,
            Literal::Unit => write!(self.output, "()")?,
        }
        Ok(())
    }

    fn emit_indent(&mut self) -> Result<(), Error> {
        for _ in 0..self.indent {
            write!(self.output, "    ")?;
        }
        Ok(())
    }
}

impl Default for CodeGenerator {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_function() {
        let module = Module {
            name: Some("test".to_string()),
            structs: vec![],
            externs: vec![],
            functions: vec![Function {
                name: "add".to_string(),
                params: vec![
                    ("a".to_string(), AnnotatedType {
                        typ: Type::Prim(PrimType::I64),
                        security: Security::Low,
                    }),
                    ("b".to_string(), AnnotatedType {
                        typ: Type::Prim(PrimType::I64),
                        security: Security::Low,
                    }),
                ],
                return_type: AnnotatedType {
                    typ: Type::Prim(PrimType::I64),
                    security: Security::Low,
                },
                body: vec![
                    Instr::Return(Some(Expr::Binop(
                        BinOp::Add,
                        Box::new(Expr::Var("a".to_string())),
                        Box::new(Expr::Var("b".to_string())),
                    ))),
                ],
                is_oblivious: false,
                is_constant_time: false,
            }],
        };

        let mut gen = CodeGenerator::new();
        let code = gen.generate(&module).unwrap();
        assert!(code.contains("pub fn add(a: i64, b: i64) -> i64"));
        assert!(code.contains("return (a + b);"));
    }
}
