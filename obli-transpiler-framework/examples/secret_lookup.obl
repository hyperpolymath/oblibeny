// SPDX-License-Identifier: MIT OR Palimpsest-0.8
// Copyright (c) 2024 Hyperpolymath

// Example: Oblivious array lookup
//
// This demonstrates how to use ORAM arrays to hide access patterns
// when indexing with secret values.

// A struct for storing records
struct Record {
    id: @low int,
    value: @high int,
}

// Oblivious lookup function
// The @oblivious attribute ensures the compiler verifies
// that no secret-dependent branches or regular array accesses occur.
@oblivious
fn lookup(data: oarray<int>, @high index: int) -> @high int {
    // oread() performs an ORAM access that hides which index was accessed
    return oread(data, index);
}

// Oblivious conditional update
@oblivious
@constant_time
fn conditional_update(
    data: oarray<int>,
    @high index: int,
    @high should_update: bool,
    @high new_value: int
) {
    // Read current value
    let current: @high int = oread(data, index);

    // Conditionally select new or old value using cmov
    // This doesn't branch on the secret condition
    let final_value: @high int = cmov(should_update, new_value, current);

    // Write back (ORAM hides which location)
    owrite(data, index, final_value);
}

// Binary search with hidden access pattern
@oblivious
fn oblivious_binary_search(
    sorted_data: oarray<int>,
    size: int,
    @high target: int
) -> @high int {
    let low: @high int = 0;
    let high: @high int = size - 1;
    let result: @high int = -1;

    // Fixed number of iterations (log2 of max size)
    for i in 0..32 {
        let mid: @high int = (low + high) / 2;
        let mid_val: @high int = oread(sorted_data, mid);

        // All comparisons use cmov, no branches on secrets
        let found: @high bool = mid_val == target;
        let go_left: @high bool = mid_val > target;

        result = cmov(found, mid, result);
        high = cmov(go_left, mid - 1, high);
        low = cmov(go_left, low, mid + 1);
    }

    return result;
}

fn main() {
    // Create an oblivious array
    let data: oarray<int> = oarray_new(1000);

    // Initialize with public data
    for i in 0..1000 {
        owrite(data, i, i * 7);
    }

    // Secret index - the access pattern will be hidden
    let secret_idx: @high int = 42;

    // This lookup hides which index was accessed
    let value: @high int = lookup(data, secret_idx);

    // Conditional update without leaking the condition
    let should_update: @high bool = true;
    conditional_update(data, secret_idx, should_update, 999);
}
