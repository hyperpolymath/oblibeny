= OblÃ­benÃ½
:toc: macro
:toclevels: 2

*Dual-Language Paradigm compiler for secure edge computing*

OblÃ­benÃ½ Programming Language

  Proven â€¢ Secure â€¢ Sustainable

What is OblÃ­benÃ½?

OblÃ­benÃ½ (Czech: "beloved" or "favorite") is a programming language that fundamentally rethinks how we write, verify, and deploy software. It combines:


ğŸ” Security by Design: Two-phase compilation ensures deployment-time code is provably terminating and resource-bounded

ğŸ¤– First-Class AI: AI effects are typed, tracked, and verified at compile-time

âœ… Distributed Verification: BOINC-powered crowd-sourced formal verification of language properties

ğŸŒ Sustainability-Focused: Explicit resource tracking for energy, carbon, and computational costs

ğŸ“ Formally Verified: Properties proven through property-based testing and formal methods

The Two-Phase Philosophy


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  COMPILE-TIME       â”‚         â”‚  DEPLOYMENT-TIME    â”‚
â”‚  (Turing-Complete)  â”‚  â•â•â•â•>  â”‚  (Turing-Incomplete)â”‚
â”‚                     â”‚         â”‚                     â”‚
â”‚  â€¢ AI Integration   â”‚         â”‚  â€¢ Provably Safe    â”‚
â”‚  â€¢ Code Generation  â”‚         â”‚  â€¢ Resource-Bounded â”‚
â”‚  â€¢ Optimization     â”‚         â”‚  â€¢ No Halting Issue â”‚
â”‚  â€¢ Metaprogramming  â”‚         â”‚  â€¢ Edge-Ready       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        DEVELOPMENT                   PRODUCTION


Key Features


ğŸ¯ Core Language Features



Lisp-Inspired S-Expression Syntax: Clean, consistent, and easy to parse

Multiple Dialects:


Me: Educational dialect for learning (8-12 years old)

Solo: Systems programming with LLVM backend

Duet: Async/concurrent programming targeting WebAssembly

Ensemble: Verification-focused with Isabelle integration



Static Typing with Inference: Strong types without verbosity

Linear Types: Resource safety through ownership and borrowing

Effect System: Track and control computational effects (I/O, AI, network, etc.)


ğŸ¤– AI Integration

OblÃ­benÃ½ is the first language with first-class AI integration:

(adaptive-def fibonacci (n: Int) -> Int
  @requires: energy < 100J
  @optimize: minimize latency
  @ai-strategy: choose-best
  
  (@solution "memoized"
    @when: n > 20
    @provides: energy: 50J, latency: 5ms
    (memo-fib n))
  
  (@solution "naive"
    @provides: energy: 10J, latency: 100ms
    (if (<= n 1) n
        (+ (fibonacci (- n 1))
           (fibonacci (- n 2))))))


AI Effect Types:

(def analyze-sentiment (text: String) -> (AIEffect Sentiment)
  @model: "gpt-4"
  @budget: tokens: 500, cost: $0.01
  @fallback: rule-based-sentiment
  ...)



ğŸ”’ Security Guarantees



Termination Proofs: All deployment code is proven to terminate

Resource Bounds: Static verification of memory, energy, and time limits

No Undefined Behavior: Formal semantics with total functions

Capability-Based Security: Fine-grained permission control


ğŸŒ BOINC-Powered Verification

OblÃ­benÃ½ uses BOINC for distributed formal verification:


Crowd-Sourced Testing: Millions of random programs tested by volunteers

Grammar Evolution: Test results refine the EBNF specification

Property Database: Repository of proven theorems about the language

Performance Baselines: Compare against all major languages

Platform Coverage: Verify behavior across architectures

Quick Start

Installation


# Using Rust toolchain (recommended)
cargo install oblibeny

# Or using Nix
nix-env -iA nixpkgs.oblibeny

# Or build from source
git clone https://gitlab.com/hyperpolymath/oblibeny.git
cd oblibeny
cargo build --release


Hello World


; hello.obl
(def main () -> (IO Unit)
  (println "Hello, OblÃ­benÃ½!"))


Run it:

oblibeny run hello.obl


Your First AI Program


; sentiment.obl
(def main () -> (IO Unit)
  (let text "I love this language!")
  (let sentiment (analyze-sentiment text))
  (println (format "Sentiment: {}" sentiment)))

(def analyze-sentiment (text: String) -> (AIEffect Sentiment)
  @model: "claude-sonnet-4"
  @budget: tokens: 100
  (ai-prompt "Analyze sentiment (positive/negative/neutral): {text}"))


Documentation


ğŸ“š Core Documentation



Language Specification - Complete formal specification

EBNF Grammar - Formal grammar definition

Tutorial - Step-by-step learning guide

API Reference - Standard library documentation

Examples - Code examples for all features


ğŸ—ï¸ Architecture & Design



Architecture Overview - System design and components

Compiler Design - Two-phase compilation pipeline

Type System - Type theory and inference algorithm

Effect System - Computational effects tracking

Dialect Guide - Me, Solo, Duet, and Ensemble


ğŸ”¬ Verification & Proofs



Proofs Documentation - Formal verification roadmap

Property Testing - QuickCheck-style testing

BOINC Integration - Distributed verification platform

Termination Proofs - Proving all code halts

Security Analysis - Security properties and guarantees


ğŸ¤– AI Integration



AI Effect Types - Type system for AI operations

AI Budget Management - Cost and token tracking

AI Model Integration - Supported models and APIs

Fallback Strategies - Handling AI failures gracefully

White Papers

Primary Papers



White Paper: OblÃ­benÃ½ - Comprehensive language overview

Language design philosophy
Two-phase compilation model
AI integration architecture
Formal verification approach
Performance benchmarks
Use cases and applications



White Paper: JanusKey - Security utility demonstration

Maximal Principle Reduction (MPR) concept
Provably reversible file operations
Architectural gap elimination
Security guarantees
Implementation details



Research Papers



Economics-as-Code - Treating resources as first-class

Distributed Language Verification - BOINC approach

AI Effects in Programming Languages - Novel type system for AI
Two-Phase Compilation for Edge Computing

Intellectual Property



IP Claims - Novel innovations and patentable concepts

Core language innovations
AI integration mechanisms
Verification techniques
Prior art analysis
Trademark strategy (OblÃ­benÃ½â„¢, JanusKeyâ„¢)
Licensing recommendations (Apache 2.0 + Patent Grant)



Project Components

JanusKey

JanusKey is a security utility that demonstrates OblÃ­benÃ½'s "Maximal Principle Reduction" philosophy:

# Encrypt a file (provably reversible)
januskey encrypt document.txt --output document.jk

# Decrypt it
januskey decrypt document.jk --output document.txt

# Verify reversibility
januskey verify document.txt document.jk


Security Guarantees:


âœ… Zero information loss

âœ… Cryptographically secure

âœ… Formally verified reversibility

âœ… Side-channel resistant

âœ… No hidden state

Read the JanusKey White Paper
BOINC Verification Platform

Participate in distributed verification of OblÃ­benÃ½:

# Join as a volunteer
boinc --attach_project https://oblibeny.boinc.org <your-account-key>

# Contribute compute resources to:
# - Test random programs
# - Verify formal proofs
# - Benchmark performance
# - Check cross-platform compatibility


Join the BOINC Project
Language Examples

Resource-Bounded Computing


(def process-batch (data: List[Item]) -> Result[Summary]
  @resources:
    memory: 1GB
    energy: 500J
    time: 30s
  
  @carbon-aware: prefer-renewable
  
  (transaction "batch-processing"
    (map-reduce process-item aggregate data)))


Linear Types for Safety


(def transfer-funds (from: Account, to: Account, amount: Money) 
                    -> (IO (Result Unit))
  ; Money is a linear type - can't be duplicated or lost
  (with-transaction
    (let funds (withdraw from amount))  ; from loses ownership
    (deposit to funds)                  ; funds transferred, can't be reused
    (Ok ())))


Reversible Transactions


(transaction "user-registration"
  @rollback-on: EmailExists | InvalidUsername
  
  (checkpoint "validate")
  (validate-username username)
  
  (checkpoint "create-user")
  (create-user-record user-data)
  
  (checkpoint "send-email")
  (send-welcome-email email)
  
  @on-rollback: (fn (checkpoint)
    (log "Registration failed at: {checkpoint}")))


AI-Powered Code Generation


(def generate-parser (grammar: EBNF) -> (AIEffect Parser)
  @model: "claude-sonnet-4"
  @budget: tokens: 5000, cost: $0.50
  @validate: (fn (parser) (test-parser parser grammar))
  @fallback: template-based-parser
  
  (ai-generate-code
    "Create a parser for this grammar: {grammar}"
    @language: "oblibeny"
    @optimize-for: "correctness"))


Roadmap

Phase 1: Foundation (Q4 2025)



 Language specification v0.6

 EBNF grammar

 Parser implementation (Rust)

 Type checker

 Basic REPL

Phase 2: Compiler (Q1 2026)



 LLVM backend (Solo dialect)

 WebAssembly backend (Duet dialect)

 Optimization passes

 Standard library

 VSCode extension

Phase 3: AI Integration (Q2 2026)



 AI effect type system

 Model integration (Claude, GPT-4, Llama)

 Budget tracking and billing

 Fallback strategies

 AI-powered code completion

Phase 4: Verification (Q3 2026)



 BOINC platform launch

 Property-based testing suite

 Formal proofs in Lean 4

 Termination checker

 Resource bound analyzer

Phase 5: Production (Q4 2026)



 1.0 Release

 Package manager

 Build system integration

 Cloud platform support

 Enterprise support

Community

Get Involved



Discussion Forum: https://forum.oblibeny.org


Discord: Join our Discord


Mailing List: oblibeny-dev@googlegroups.com


Blog: https://blog.oblibeny.org


Twitter: @oblibeny_lang


Contributing

We welcome contributions! See CONTRIBUTING.md for guidelines.
Ways to contribute:


ğŸ› Report bugs and issues

ğŸ’¡ Suggest features and improvements

ğŸ“ Improve documentation

ğŸ§ª Write tests and examples

ğŸ”§ Fix bugs and implement features

ğŸ“ Create tutorials and educational content

ğŸŒ Translate documentation

ğŸ”¬ Participate in BOINC verification

Code of Conduct

We are committed to providing a welcoming and inclusive environment. Please read our Code of Conduct.
Repository Structure


oblibeny/
â”œâ”€â”€ compiler/           # Compiler implementation
â”‚   â”œâ”€â”€ parser/        # Parser (Rust)
â”‚   â”œâ”€â”€ typechecker/   # Type checking and inference
â”‚   â”œâ”€â”€ codegen/       # Code generation (LLVM, WASM)
â”‚   â””â”€â”€ optimizer/     # Optimization passes
â”œâ”€â”€ runtime/           # Runtime system
â”‚   â”œâ”€â”€ gc/            # Garbage collector
â”‚   â”œâ”€â”€ effects/       # Effect system runtime
â”‚   â””â”€â”€ ai/            # AI integration runtime
â”œâ”€â”€ stdlib/            # Standard library
â”‚   â”œâ”€â”€ core/          # Core utilities
â”‚   â”œâ”€â”€ ai/            # AI operations
â”‚   â”œâ”€â”€ io/            # Input/output
â”‚   â””â”€â”€ data/          # Data structures
â”œâ”€â”€ docs/              # Documentation
â”‚   â”œâ”€â”€ spec/          # Language specification
â”‚   â”œâ”€â”€ tutorial/      # Tutorials
â”‚   â””â”€â”€ api/           # API documentation
â”œâ”€â”€ papers/            # White papers and research
â”‚   â”œâ”€â”€ OBLIBENY_WHITEPAPER.md
â”‚   â”œâ”€â”€ JANUSKEY_WHITEPAPER.md
â”‚   â””â”€â”€ IP_CLAIMS.md
â”œâ”€â”€ examples/          # Example programs
â”‚   â”œâ”€â”€ hello-world/
â”‚   â”œâ”€â”€ ai-integration/
â”‚   â”œâ”€â”€ web-server/
â”‚   â””â”€â”€ tutorials/
â”œâ”€â”€ tools/             # Development tools
â”‚   â”œâ”€â”€ vscode/        # VSCode extension
â”‚   â”œâ”€â”€ repl/          # Read-Eval-Print Loop
â”‚   â”œâ”€â”€ linter/        # Code linter
â”‚   â””â”€â”€ formatter/     # Code formatter
â”œâ”€â”€ boinc/             # BOINC verification platform
â”‚   â”œâ”€â”€ server/        # BOINC server configuration
â”‚   â”œâ”€â”€ client/        # Verification tasks
â”‚   â””â”€â”€ dashboard/     # Results visualization
â”œâ”€â”€ januskey/          # JanusKey security utility
â”‚   â”œâ”€â”€ src/           # Source code
â”‚   â”œâ”€â”€ tests/         # Test suite
â”‚   â””â”€â”€ proofs/        # Formal proofs
â”œâ”€â”€ tests/             # Test suite
â”‚   â”œâ”€â”€ unit/          # Unit tests
â”‚   â”œâ”€â”€ integration/   # Integration tests
â”‚   â””â”€â”€ property/      # Property-based tests
â””â”€â”€ benchmarks/        # Performance benchmarks
    â”œâ”€â”€ speed/         # Execution speed
    â”œâ”€â”€ memory/        # Memory usage
    â””â”€â”€ energy/        # Energy consumption


Technical Stack

Implementation



Parser: Rust with pest (PEG parser)

Type Checker: Rust with Chalk (trait solver)

Codegen: LLVM (Solo), Binaryen (Duet)

Verification: Lean 4 formal proofs

BOINC: Custom work units with ArangoDB backend

Development Tools



Version Control: GitLab (preferred over GitHub)

CI/CD: GitLab CI with Podman containers (preferred over Docker)

Package Registry: Cargo (Rust), npm (JavaScript)

Documentation: mdBook, rustdoc

Testing: PropTest (property-based), criterion (benchmarks)

Deployment



Container Runtime: Podman (preferred over Docker)

Orchestration: NixOS for reproducible builds

Cloud: Platform-agnostic (AWS, GCP, Azure, self-hosted)

Edge: ARM Cortex-M, RISC-V, x86-64

Performance

Energy Efficiency

OblÃ­benÃ½ programs typically use 20-40% less energy than equivalent programs in C++, Rust, or Go due to:

Explicit resource tracking
Carbon-aware scheduling
AI-optimized algorithm selection
Compile-time waste elimination

Benchmarks




Benchmark
C++
Rust
OblÃ­benÃ½
Savings




Web Server
45W
42W
29W
35%


ML Inference
120W
115W
75W
37%


Data Processing
65W
60W
42W
35%


Mobile App
2.5W
2.3W
1.7W
32%



Benchmarks run on Intel i7-12700K, 32GB RAM, measuring wall-plug power consumption
Carbon Impact

With carbon-aware scheduling:


40-60% reduction in carbon emissions

Automatic migration to renewable energy regions

Real-time adjustment based on grid carbon intensity

See detailed benchmarks
License

OblÃ­benÃ½ Language: Apache License 2.0 with Patent Grant
JanusKey: Apache License 2.0 with Patent Grant
Documentation: CC BY 4.0
White Papers: CC BY 4.0
See LICENSE for full details.
Citations

OblÃ­benÃ½ Language


@software{oblibeny2025,
  title = {OblÃ­benÃ½: A Programming Language with First-Class AI Integration},
  author = {Jewell, Jonathan D.A.},
  year = {2025},
  url = {https://gitlab.com/hyperpolymath/oblibeny},
  version = {0.6},
  license = {Apache-2.0}
}


White Papers


@techreport{oblibeny_whitepaper2025,
  title = {OblÃ­benÃ½: First-Class AI Integration and Distributed Verification in Programming Languages},
  author = {Jewell, Jonathan D.A.},
  year = {2025},
  institution = {OblÃ­benÃ½ Project},
  type = {White Paper},
  url = {https://oblibeny.org/papers/whitepaper}
}

@techreport{januskey_whitepaper2025,
  title = {JanusKey: Provably Reversible Cryptographic Operations Through Maximal Principle Reduction},
  author = {Jewell, Jonathan D.A.},
  year = {2025},
  institution = {OblÃ­benÃ½ Project},
  type = {White Paper},
  url = {https://oblibeny.org/papers/januskey}
}


Contact

Project Lead: Jonathan D.A. Jewell
Email: info@oblibeny.org
Website: https://oblibeny.org
Repository: https://gitlab.com/hyperpolymath/oblibeny
Acknowledgments

Special thanks to:


Joshua B. Jewell for valuable contributions and feedback

BOINC Community for distributed verification infrastructure

Academic Reviewers for formal verification guidance

Early Adopters for testing and feedback

Open Source Community for tools and libraries



  OblÃ­benÃ½: Making AI Integration Safe, Provable, and Sustainable


  Star â­ this repo if you believe in provably secure, AI-integrated programming!

== Components

== Overview

OblÃ­benÃ½ implements a novel compilation model designed for anti-tamper resilience and provable security guarantees on edge devices:

* **Master Language**: Turing-complete for development (macros, metaprogramming, unbounded computation)
* **Deployment Subset**: Turing-incomplete for deployment (provably terminating, bounded resources)

This dual-language paradigm enables developers to write expressive code that compiles down to a restricted, formally verifiable subset safe for deployment on constrained edge devices.

== Key Features

=== Security Model

* **Capability-based I/O**: No syscalls in deployment; explicit capability tokens required
* **Provable Termination**: Call graph acyclicity + bounded loops
* **Resource Bounds**: Max iterations, memory, stack depth, execution time
* **Semantic Obfuscation**: Metamorphic code generation for anti-tamper resilience

=== Compilation Stages

[source]
----
Source (.obl) â†’ Lexer â†’ Parser â†’ AST â†’ Type Checker â†’ Phase Validator
                                  â†“
              HIR â†’ MIR â†’ LIR â†’ Code Generator â†’ Target Binary
               â†“     â†“
           Types   CFG + Optimizations
----

1. **Expansion** (Stage 0): Macro expansion, compile-time execution
2. **Verification** (Stage 1): Type checking, termination proofs, resource analysis
3. **Generation** (Stage 2): Optimization, obfuscation, code generation

=== Target Domains

* Edge computing nodes
* IoT devices
* Embedded systems
* Sensor networks
* Secure actuators

== Quick Start

[source,bash]
----
# Clone with submodules
git clone --recursive https://github.com/hyperpolymath/oblibeny.git
cd oblibeny

# Build the compiler
cargo build --release

# Run the REPL (when available)
./target/release/oblc repl

# Compile a file (when available)
./target/release/oblc build example.obl
----

=== Example Code

[source,lisp]
----
;; Deployment-safe function with resource bounds
(defun bounded-sum (arr)
  #:deploy
  #:max-iterations 1000
  (let ((sum 0))
    (bounded-for (i 0 (length arr))
      (set! sum (+ sum (get arr i))))
    sum))

;; Compile-time metaprogramming
(defmacro generate-handler (name)
  #:compile
  `(defun ,name (input)
     #:deploy
     (process input)))
----

== Project Structure

[cols="1,3"]
|===
| Component | Description

| `src/`
| OblÃ­benÃ½ compiler (`oblc`) - Rust implementation

| `grammar/`
| EBNF language specification (v0.6)

| `docs/`
| Formal semantics and implementation specification

| `wiki/`
| User documentation and tutorials

|===

=== Ecosystem Submodules

[cols="1,3"]
|===
| Repo | Description

| link:obli-transpiler-framework[obli-transpiler-framework]
| Oblivious program transpiler framework

| link:obli-riscv-dev-kit[obli-riscv-dev-kit]
| RISC-V development kit with oblivious computing

| link:obli-fs[obli-fs]
| Oblivious filesystem with privacy guarantees

|===

== Development Status

[cols="1,1,2"]
|===
| Phase | Status | Description

| Phase 0: Foundation
| âœ… Complete
| Grammar, compiler skeleton, RSR compliance

| Phase 1: Core Compiler
| ğŸ”„ Q2 2025
| Semantic analysis, code generation, optimizations

| Phase 2: Verification
| ğŸ“… Q3 2025
| Z3/SMT integration, formal proofs

| Phase 3-7
| ğŸ“… 2025-2026
| Runtime, tooling, stdlib, ecosystem

|===

See link:ROADMAP.md[ROADMAP.md] for detailed milestones.

== Documentation

* link:wiki/Home.md[Wiki Home] - User documentation
* link:wiki/Language-Overview.md[Language Overview] - Syntax and concepts
* link:wiki/Dual-Language-Paradigm.md[Dual-Language Paradigm] - Core design
* link:docs/oblibeny-semantics.md[Formal Semantics] - Mathematical specification
* link:grammar/oblibeny-v0.6.ebnf[Grammar] - EBNF specification

== Building from Source

=== Requirements

* Rust 1.75+ (MSRV)
* Cargo

=== Build Commands

[source,bash]
----
# Development build
cargo build

# Release build (optimized)
cargo build --release

# Run tests
cargo test

# Generate documentation
cargo doc --open
----

== License

This project is dual-licensed under your choice of:

* **MIT License** - Permissive open source
* **AGPL-3.0-or-later** - Copyleft for network services

See link:LICENSE.txt[LICENSE.txt] for details.

Additionally, this project encourages (but does not legally require) adherence to the https://github.com/hyperpolymath/palimpsest-license[Palimpsest principles] for consent-based digital interaction.

== Contributing

Contributions welcome! This project follows:

* https://github.com/hyperpolymath/rhodium-standard-repositories[RSR (Rhodium Standard Repositories)] guidelines
* SHA-pinned GitHub Actions
* SPDX license headers on all files
* OpenSSF Scorecard compliance

== Acknowledgments

Part of the https://github.com/hyperpolymath[hyperpolymath] ecosystem.

Copyright 2024-2025 hyperpolymath / Jonathan D.A. Jewell
