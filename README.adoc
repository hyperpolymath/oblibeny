image:https://img.shields.io/badge/License-MPL_2.0-blue.svg[MPL-2.0,link="https://opensource.org/licenses/MPL-2.0"]
image:https://img.shields.io/badge/Philosophy-Palimpsest-purple.svg[Palimpsest,link="https://github.com/hyperpolymath/palimpsest-licence"]

// SPDX-License-Identifier: MIT OR Palimpsest-0.8
// SPDX-FileCopyrightText: 2026 Hyperpolymath

= Oblíbený

:toc:
:toclevels: 2

*A secure edge language: a Turing-complete meta/factory form that produces a Turing-incomplete reversible/constraint form, designed for accountability.*

== Overview

Oblíbený is a dual-form language for building secure, accountable, and reversible computations.

[cols="1,3"]
|===
| *Project* | Oblíbený
| *Kind* | Secure edge language for reversibility + accountability
| *Domain* | MAA + Absolute-Zero integration
|===

=== Core Architecture

Oblíbený has a **dual-form** design:

1. **Factory Form** (Turing-complete)
   - Used for metaprogramming and code generation
   - Executes at compile/factory time
   - Produces constrained form programs

2. **Constrained Form** (Turing-incomplete)
   - The runtime form of all Oblíbený programs
   - Guarantees termination
   - All operations are reversible
   - Every execution produces an accountability trace

=== Why Turing-Incomplete?

The constrained form is **intentionally** Turing-incomplete:

* **Termination guaranteed** - All programs halt in bounded time
* **Full reversibility** - Every operation can be undone
* **Bounded resources** - Memory and time usage are statically known
* **Complete accountability** - Finite, verifiable audit trails

== Quick Start

[source,bash]
----
# Build the language
dune build

# Run the test suite
dune test

# Execute an example
dune exec -- oblibeny examples/hello.obl
----

=== Example Program

[source]
----
// hello.obl - demonstrating core concepts
fn main() -> () {
    let mut counter = 0;
    checkpoint("start");

    // Bounded loop with static bound (no while/loop allowed)
    for i in 0..10 {
        incr(counter, 1);      // Reversible increment
        trace("counted", counter);
    }

    checkpoint("end");
    assert_invariant(counter == 10, "counter should be 10");

    // Reversible swap (self-inverse)
    let mut a = 42;
    let mut b = 7;
    swap(a, b);
}
----

== Constrained Form Rules

The constrained form enforces Turing-incompleteness **syntactically**:

[cols="1,2"]
|===
| Rule | Description

| No `while` loops | The `while` keyword is rejected by the parser
| No `loop` keyword | The `loop` keyword is rejected by the parser
| No recursion | Functions cannot call themselves directly or indirectly
| Static loop bounds | `for-range` bounds must be compile-time constants
| Acyclic call graph | The function call graph must be a DAG
|===

== Reversibility Primitives

[cols="1,2,1"]
|===
| Operation | Description | Inverse

| `swap(a, b)` | Exchange values | Self-inverse
| `incr(x, delta)` | Increment by delta | `decr(x, delta)`
| `decr(x, delta)` | Decrement by delta | `incr(x, delta)`
| `x ^= val` | XOR-assign | Self-inverse
|===

== Accountability Trace

Every execution produces an append-only trace:

* Records all operations with inputs and outputs
* Supports checkpoints for structured logging
* Cryptographically hashable for integrity
* Sufficient information to reverse any operation

== Project Structure

----
oblibeny/
├── ANCHOR.scope-arrest.2026-01-01.Jewell.scm  # Project identity anchor
├── SPEC.core.scm          # Formal language specification
├── README.adoc            # This file
├── lib/                   # Core language implementation (OCaml)
│   ├── ast.ml             # Abstract syntax tree
│   ├── constrained_check.ml  # Turing-incompleteness validation
│   ├── eval.ml            # Reference evaluator
│   └── trace.ml           # Accountability trace
├── bin/                   # CLI driver
├── test/                  # Conformance test suite
└── examples/              # Example programs
----

== External Integrations

Oblíbený defines interfaces (not implementations) for:

* **MAA (Mutually-Assured-Accountability)** - Trace commitment and verification
* **Absolute-Zero** - Privacy-preserving proofs over traces

See `SPEC.core.scm` Section 6 for interface contracts.

== Related Projects

The following were previously part of this repository but have distinct identities:

* `obli-transpiler-framework` - Oblivious computing transpiler (see link:obli-transpiler-framework/README.md[README])
* `obli-riscv-dev-kit` - RISC-V development kit
* `obli-fs` - Oblivious filesystem

NOTE: Per the scope anchor, these should be relocated to sibling repositories.

== Technology Standards

This project follows the link:.claude/CLAUDE.md[Hyperpolymath Language Policy]:

* **Implementation language:** OCaml (authoritative reference)
* **Optional backends:** Rust (quarantined, non-authoritative)
* **Runtime:** Deno (for tooling)
* **Packages:** Guix/Nix for reproducible builds

== License

MIT OR Palimpsest-0.8

== Links

* link:SPEC.core.scm[Language Specification]
* link:ANCHOR.scope-arrest.2026-01-01.Jewell.scm[Scope Anchor]
* https://github.com/hyperpolymath[Hyperpolymath Organization]
