// SPDX-License-Identifier: AGPL-3.0-or-later
// SPDX-FileCopyrightText: 2025 Jonathan D.A. Jewell

//! Code generation module for Oblíbený.
//!
//! This module transforms MIR into executable code for various targets.
//! The initial implementation targets x86-64 assembly.
//!
//! # Architecture
//!
//! ```text
//! MIR -> Instruction Selection -> Register Allocation -> Emission
//! ```
//!
//! # Supported Targets
//!
//! - x86-64 (Linux, macOS, Windows)
//! - WebAssembly (planned)
//! - ARM64 (planned)

pub mod emitter;
pub mod regalloc;

use crate::mir::{
    BasicBlock, BinOp, BlockId, CallTarget, ConstValue, Local, MirFunction, MirInstr, MirProgram,
    MirType, Operand, Place, RValue, Terminator, UnaryOp,
};
use std::collections::HashMap;
use std::fmt::Write;

/// Target architecture for code generation
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Target {
    /// x86-64 architecture
    X86_64,
    /// WebAssembly
    Wasm,
    /// ARM64 / AArch64
    Arm64,
}

impl Default for Target {
    fn default() -> Self {
        Target::X86_64
    }
}

/// Code generator for Oblíbený programs
pub struct CodeGenerator {
    /// Target architecture
    target: Target,
    /// Output buffer
    output: String,
    /// Label counter for unique labels
    label_counter: u32,
    /// Mapping from block IDs to labels
    block_labels: HashMap<BlockId, String>,
    /// Current function being generated
    current_function: Option<String>,
}

impl CodeGenerator {
    /// Create a new code generator for the specified target
    pub fn new(target: Target) -> Self {
        CodeGenerator {
            target,
            output: String::new(),
            label_counter: 0,
            block_labels: HashMap::new(),
            current_function: None,
        }
    }

    /// Generate code for a complete MIR program
    pub fn generate(&mut self, program: &MirProgram) -> String {
        self.output.clear();

        match self.target {
            Target::X86_64 => self.generate_x86_64(program),
            Target::Wasm => self.generate_wasm(program),
            Target::Arm64 => self.generate_arm64(program),
        }

        std::mem::take(&mut self.output)
    }

    /// Generate x86-64 assembly
    fn generate_x86_64(&mut self, program: &MirProgram) {
        // Assembly header
        writeln!(&mut self.output, "; Generated by Oblíbený compiler").unwrap();
        writeln!(&mut self.output, "; Target: x86-64").unwrap();
        writeln!(&mut self.output).unwrap();
        writeln!(&mut self.output, "section .text").unwrap();

        // Generate functions
        for func in &program.functions {
            self.generate_function_x86_64(func);
        }

        // Generate data section
        if !program.constants.is_empty() || !program.statics.is_empty() {
            writeln!(&mut self.output).unwrap();
            writeln!(&mut self.output, "section .data").unwrap();

            for constant in &program.constants {
                self.generate_constant_x86_64(constant);
            }

            for static_var in &program.statics {
                self.generate_static_x86_64(static_var);
            }
        }
    }

    /// Generate a function for x86-64
    fn generate_function_x86_64(&mut self, func: &MirFunction) {
        self.current_function = Some(func.name.clone());
        self.block_labels.clear();

        // Assign labels to blocks
        for block in &func.blocks {
            let label = format!(".L{}_{}", func.name, block.id.0);
            self.block_labels.insert(block.id, label);
        }

        // Function header
        writeln!(&mut self.output).unwrap();
        writeln!(&mut self.output, "global {}", func.name).unwrap();
        writeln!(&mut self.output, "{}:", func.name).unwrap();

        // Prologue
        writeln!(&mut self.output, "    push rbp").unwrap();
        writeln!(&mut self.output, "    mov rbp, rsp").unwrap();

        // Calculate stack frame size (simplified)
        let frame_size = self.calculate_frame_size(func);
        if frame_size > 0 {
            writeln!(&mut self.output, "    sub rsp, {}", frame_size).unwrap();
        }

        // Generate basic blocks
        for block in &func.blocks {
            self.generate_block_x86_64(func, block);
        }

        self.current_function = None;
    }

    /// Calculate stack frame size needed for locals
    fn calculate_frame_size(&self, func: &MirFunction) -> u64 {
        let mut size = 0u64;
        for local in &func.locals {
            size += self.type_size(&local.ty);
        }
        // Align to 16 bytes
        (size + 15) & !15
    }

    /// Get the size of a type in bytes
    fn type_size(&self, ty: &MirType) -> u64 {
        match ty {
            MirType::Unit => 0,
            MirType::Bool => 1,
            MirType::Int(bits) | MirType::UInt(bits) | MirType::Float(bits) => {
                (*bits as u64 + 7) / 8
            }
            MirType::Ptr(_) => 8,
            MirType::Array(elem, count) => self.type_size(elem) * count,
            MirType::Aggregate(_) => 8, // Placeholder
            MirType::FnPtr { .. } => 8,
            MirType::Error => 0,
        }
    }

    /// Generate a basic block for x86-64
    fn generate_block_x86_64(&mut self, func: &MirFunction, block: &BasicBlock) {
        let label = self.block_labels.get(&block.id).unwrap().clone();
        writeln!(&mut self.output, "{}:", label).unwrap();

        // Generate phi nodes as parallel moves (simplified)
        // Real implementation would need careful handling

        // Generate instructions
        for instr in &block.instructions {
            self.generate_instr_x86_64(func, instr);
        }

        // Generate terminator
        self.generate_terminator_x86_64(func, &block.terminator);
    }

    /// Generate an instruction for x86-64
    fn generate_instr_x86_64(&mut self, func: &MirFunction, instr: &MirInstr) {
        match instr {
            MirInstr::Nop => {
                writeln!(&mut self.output, "    nop").unwrap();
            }

            MirInstr::Assign { dest, value, .. } => {
                // Simplified: assume locals are in stack slots
                let dest_offset = self.local_offset(func, *dest);

                match value {
                    RValue::Use(operand) => {
                        let src = self.operand_to_x86_64(func, operand);
                        writeln!(&mut self.output, "    mov rax, {}", src).unwrap();
                        writeln!(&mut self.output, "    mov [rbp-{}], rax", dest_offset).unwrap();
                    }

                    RValue::BinOp { op, left, right } => {
                        let left_src = self.operand_to_x86_64(func, left);
                        let right_src = self.operand_to_x86_64(func, right);

                        writeln!(&mut self.output, "    mov rax, {}", left_src).unwrap();
                        writeln!(&mut self.output, "    mov rcx, {}", right_src).unwrap();

                        match op {
                            BinOp::Add => writeln!(&mut self.output, "    add rax, rcx").unwrap(),
                            BinOp::Sub => writeln!(&mut self.output, "    sub rax, rcx").unwrap(),
                            BinOp::Mul => writeln!(&mut self.output, "    imul rax, rcx").unwrap(),
                            BinOp::Div => {
                                writeln!(&mut self.output, "    cqo").unwrap();
                                writeln!(&mut self.output, "    idiv rcx").unwrap();
                            }
                            BinOp::Rem => {
                                writeln!(&mut self.output, "    cqo").unwrap();
                                writeln!(&mut self.output, "    idiv rcx").unwrap();
                                writeln!(&mut self.output, "    mov rax, rdx").unwrap();
                            }
                            BinOp::BitAnd => {
                                writeln!(&mut self.output, "    and rax, rcx").unwrap()
                            }
                            BinOp::BitOr => writeln!(&mut self.output, "    or rax, rcx").unwrap(),
                            BinOp::BitXor => {
                                writeln!(&mut self.output, "    xor rax, rcx").unwrap()
                            }
                            BinOp::Shl => writeln!(&mut self.output, "    shl rax, cl").unwrap(),
                            BinOp::Shr => writeln!(&mut self.output, "    sar rax, cl").unwrap(),
                            BinOp::Eq => {
                                writeln!(&mut self.output, "    cmp rax, rcx").unwrap();
                                writeln!(&mut self.output, "    sete al").unwrap();
                                writeln!(&mut self.output, "    movzx rax, al").unwrap();
                            }
                            BinOp::Ne => {
                                writeln!(&mut self.output, "    cmp rax, rcx").unwrap();
                                writeln!(&mut self.output, "    setne al").unwrap();
                                writeln!(&mut self.output, "    movzx rax, al").unwrap();
                            }
                            BinOp::Lt => {
                                writeln!(&mut self.output, "    cmp rax, rcx").unwrap();
                                writeln!(&mut self.output, "    setl al").unwrap();
                                writeln!(&mut self.output, "    movzx rax, al").unwrap();
                            }
                            BinOp::Le => {
                                writeln!(&mut self.output, "    cmp rax, rcx").unwrap();
                                writeln!(&mut self.output, "    setle al").unwrap();
                                writeln!(&mut self.output, "    movzx rax, al").unwrap();
                            }
                            BinOp::Gt => {
                                writeln!(&mut self.output, "    cmp rax, rcx").unwrap();
                                writeln!(&mut self.output, "    setg al").unwrap();
                                writeln!(&mut self.output, "    movzx rax, al").unwrap();
                            }
                            BinOp::Ge => {
                                writeln!(&mut self.output, "    cmp rax, rcx").unwrap();
                                writeln!(&mut self.output, "    setge al").unwrap();
                                writeln!(&mut self.output, "    movzx rax, al").unwrap();
                            }
                            BinOp::And | BinOp::Or => {
                                // Logical ops treated as bitwise for now
                                if *op == BinOp::And {
                                    writeln!(&mut self.output, "    and rax, rcx").unwrap();
                                } else {
                                    writeln!(&mut self.output, "    or rax, rcx").unwrap();
                                }
                            }
                        }

                        writeln!(&mut self.output, "    mov [rbp-{}], rax", dest_offset).unwrap();
                    }

                    RValue::UnaryOp { op, operand } => {
                        let src = self.operand_to_x86_64(func, operand);
                        writeln!(&mut self.output, "    mov rax, {}", src).unwrap();

                        match op {
                            UnaryOp::Neg => writeln!(&mut self.output, "    neg rax").unwrap(),
                            UnaryOp::Not => writeln!(&mut self.output, "    not rax").unwrap(),
                            UnaryOp::LogicalNot => {
                                writeln!(&mut self.output, "    test rax, rax").unwrap();
                                writeln!(&mut self.output, "    sete al").unwrap();
                                writeln!(&mut self.output, "    movzx rax, al").unwrap();
                            }
                        }

                        writeln!(&mut self.output, "    mov [rbp-{}], rax", dest_offset).unwrap();
                    }

                    RValue::Load { ptr, .. } => {
                        let ptr_src = self.operand_to_x86_64(func, ptr);
                        writeln!(&mut self.output, "    mov rax, {}", ptr_src).unwrap();
                        writeln!(&mut self.output, "    mov rax, [rax]").unwrap();
                        writeln!(&mut self.output, "    mov [rbp-{}], rax", dest_offset).unwrap();
                    }

                    _ => {
                        writeln!(
                            &mut self.output,
                            "    ; TODO: unimplemented rvalue {:?}",
                            value
                        )
                        .unwrap();
                    }
                }
            }

            MirInstr::Store { ptr, value, .. } => {
                let ptr_src = self.operand_to_x86_64(func, ptr);
                let val_src = self.operand_to_x86_64(func, value);
                writeln!(&mut self.output, "    mov rax, {}", ptr_src).unwrap();
                writeln!(&mut self.output, "    mov rcx, {}", val_src).unwrap();
                writeln!(&mut self.output, "    mov [rax], rcx").unwrap();
            }

            MirInstr::Call {
                dest, func: target, args, ..
            } => {
                // Pass arguments in registers (System V AMD64 ABI)
                let arg_regs = ["rdi", "rsi", "rdx", "rcx", "r8", "r9"];

                for (i, arg) in args.iter().enumerate() {
                    if i < arg_regs.len() {
                        let arg_src = self.operand_to_x86_64(func, arg);
                        writeln!(&mut self.output, "    mov {}, {}", arg_regs[i], arg_src).unwrap();
                    } else {
                        // Push to stack (simplified)
                        let arg_src = self.operand_to_x86_64(func, arg);
                        writeln!(&mut self.output, "    push {}", arg_src).unwrap();
                    }
                }

                match target {
                    CallTarget::Direct(sym_id) => {
                        // Simplified: use symbol ID as function name
                        writeln!(&mut self.output, "    call func_{}", sym_id.0).unwrap();
                    }
                    CallTarget::Indirect(ptr) => {
                        let ptr_src = self.operand_to_x86_64(func, ptr);
                        writeln!(&mut self.output, "    call {}", ptr_src).unwrap();
                    }
                }

                // Store result
                if let Some(dest_local) = dest {
                    let dest_offset = self.local_offset(func, *dest_local);
                    writeln!(&mut self.output, "    mov [rbp-{}], rax", dest_offset).unwrap();
                }
            }

            MirInstr::InvokeCapability { .. } => {
                writeln!(&mut self.output, "    ; TODO: invoke capability").unwrap();
            }

            MirInstr::InlineAsm { asm, .. } => {
                // Emit inline assembly directly
                for line in asm.lines() {
                    writeln!(&mut self.output, "    {}", line).unwrap();
                }
            }
        }
    }

    /// Generate terminator for x86-64
    fn generate_terminator_x86_64(&mut self, func: &MirFunction, term: &Terminator) {
        match term {
            Terminator::Goto(target) => {
                let label = self.block_labels.get(target).unwrap();
                writeln!(&mut self.output, "    jmp {}", label).unwrap();
            }

            Terminator::Branch {
                cond,
                then_block,
                else_block,
            } => {
                let cond_src = self.operand_to_x86_64(func, cond);
                let then_label = self.block_labels.get(then_block).unwrap().clone();
                let else_label = self.block_labels.get(else_block).unwrap().clone();

                writeln!(&mut self.output, "    mov rax, {}", cond_src).unwrap();
                writeln!(&mut self.output, "    test rax, rax").unwrap();
                writeln!(&mut self.output, "    jz {}", else_label).unwrap();
                writeln!(&mut self.output, "    jmp {}", then_label).unwrap();
            }

            Terminator::Switch {
                value,
                cases,
                default,
            } => {
                let value_src = self.operand_to_x86_64(func, value);
                let default_label = self.block_labels.get(default).unwrap().clone();

                writeln!(&mut self.output, "    mov rax, {}", value_src).unwrap();

                for (case_val, target) in cases {
                    let target_label = self.block_labels.get(target).unwrap();
                    writeln!(&mut self.output, "    cmp rax, {}", case_val).unwrap();
                    writeln!(&mut self.output, "    je {}", target_label).unwrap();
                }

                writeln!(&mut self.output, "    jmp {}", default_label).unwrap();
            }

            Terminator::Return(value) => {
                if let Some(val) = value {
                    let val_src = self.operand_to_x86_64(func, val);
                    writeln!(&mut self.output, "    mov rax, {}", val_src).unwrap();
                }

                // Epilogue
                writeln!(&mut self.output, "    mov rsp, rbp").unwrap();
                writeln!(&mut self.output, "    pop rbp").unwrap();
                writeln!(&mut self.output, "    ret").unwrap();
            }

            Terminator::Unreachable => {
                writeln!(&mut self.output, "    ud2 ; unreachable").unwrap();
            }

            Terminator::Abort => {
                writeln!(&mut self.output, "    call abort").unwrap();
            }
        }
    }

    /// Get the stack offset for a local variable
    fn local_offset(&self, func: &MirFunction, local: Local) -> u64 {
        let mut offset = 0u64;
        for (i, local_decl) in func.locals.iter().enumerate() {
            offset += self.type_size(&local_decl.ty);
            if i == local.0 as usize {
                return offset;
            }
        }
        offset
    }

    /// Convert an operand to x86-64 assembly syntax
    fn operand_to_x86_64(&self, func: &MirFunction, operand: &Operand) -> String {
        match operand {
            Operand::Local(local) => {
                let offset = self.local_offset(func, *local);
                format!("[rbp-{}]", offset)
            }
            Operand::Const(c) => match c {
                ConstValue::Bool(b) => if *b { "1" } else { "0" }.to_string(),
                ConstValue::Int(i) => i.to_string(),
                ConstValue::UInt(u) => u.to_string(),
                ConstValue::Float(f) => format!("__float64__({})", f),
                _ => "0".to_string(),
            },
            Operand::ConstRef(id) => format!("const_{}", id.0),
            Operand::StaticRef(id) => format!("static_{}", id.0),
        }
    }

    /// Generate a constant for x86-64
    fn generate_constant_x86_64(&mut self, constant: &crate::mir::MirConstant) {
        write!(&mut self.output, "const_{}: ", constant.id.0).unwrap();
        self.emit_const_value_x86_64(&constant.value);
        writeln!(&mut self.output).unwrap();
    }

    /// Generate a static variable for x86-64
    fn generate_static_x86_64(&mut self, static_var: &crate::mir::MirStatic) {
        writeln!(&mut self.output, "global {}", static_var.name).unwrap();
        write!(&mut self.output, "{}: ", static_var.name).unwrap();

        if let Some(init) = &static_var.init {
            self.emit_const_value_x86_64(init);
        } else {
            let size = self.type_size(&static_var.ty);
            write!(&mut self.output, "resb {}", size).unwrap();
        }
        writeln!(&mut self.output).unwrap();
    }

    /// Emit a constant value in x86-64 data section format
    fn emit_const_value_x86_64(&mut self, value: &ConstValue) {
        match value {
            ConstValue::Bool(b) => write!(&mut self.output, "db {}", if *b { 1 } else { 0 }).unwrap(),
            ConstValue::Int(i) => write!(&mut self.output, "dq {}", i).unwrap(),
            ConstValue::UInt(u) => write!(&mut self.output, "dq {}", u).unwrap(),
            ConstValue::Float(f) => write!(&mut self.output, "dq {}", f.to_bits()).unwrap(),
            ConstValue::Str(idx) => write!(&mut self.output, "dq str_{}", idx).unwrap(),
            ConstValue::Array(elements) => {
                for (i, elem) in elements.iter().enumerate() {
                    if i > 0 {
                        write!(&mut self.output, ", ").unwrap();
                    }
                    self.emit_const_value_x86_64(elem);
                }
            }
            ConstValue::Aggregate(fields) => {
                for (i, field) in fields.iter().enumerate() {
                    if i > 0 {
                        write!(&mut self.output, ", ").unwrap();
                    }
                    self.emit_const_value_x86_64(field);
                }
            }
            ConstValue::ZeroInit => write!(&mut self.output, "dq 0").unwrap(),
            ConstValue::Undef => write!(&mut self.output, "dq 0 ; undef").unwrap(),
        }
    }

    /// Generate WebAssembly (stub)
    fn generate_wasm(&mut self, _program: &MirProgram) {
        writeln!(&mut self.output, ";; WebAssembly code generation not yet implemented").unwrap();
    }

    /// Generate ARM64 assembly (stub)
    fn generate_arm64(&mut self, _program: &MirProgram) {
        writeln!(&mut self.output, "; ARM64 code generation not yet implemented").unwrap();
    }

    /// Create a unique label
    fn unique_label(&mut self, prefix: &str) -> String {
        let label = format!(".L{}_{}", prefix, self.label_counter);
        self.label_counter += 1;
        label
    }
}

impl Default for CodeGenerator {
    fn default() -> Self {
        Self::new(Target::default())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::mir::{MirBuilder, MirType, Terminator};
    use crate::span::Span;
    use crate::symbol::SymbolId;

    fn create_test_program() -> MirProgram {
        let mut program = MirProgram::new();

        let mut func = MirFunction::new(
            SymbolId(0),
            "add".to_string(),
            vec![MirType::Int(64), MirType::Int(64)],
            MirType::Int(64),
            true,
            Span::new(0, 0),
        );

        let entry = func.add_block();
        func.entry = entry;

        // Add locals for parameters and result
        let a = func.add_local("a".to_string(), MirType::Int(64), Span::new(0, 0));
        let b = func.add_local("b".to_string(), MirType::Int(64), Span::new(0, 0));
        let result = func.add_local("result".to_string(), MirType::Int(64), Span::new(0, 0));

        // result = a + b
        func.blocks[0].instructions.push(MirInstr::Assign {
            dest: result,
            value: RValue::BinOp {
                op: BinOp::Add,
                left: Operand::Local(a),
                right: Operand::Local(b),
            },
            span: Span::new(0, 0),
        });

        // return result
        func.blocks[0].terminator = Terminator::Return(Some(Operand::Local(result)));

        program.functions.push(func);
        program
    }

    #[test]
    fn test_generate_simple_function() {
        let program = create_test_program();
        let mut codegen = CodeGenerator::new(Target::X86_64);
        let output = codegen.generate(&program);

        assert!(output.contains("global add"));
        assert!(output.contains("add:"));
        assert!(output.contains("push rbp"));
        assert!(output.contains("ret"));
    }

    #[test]
    fn test_type_sizes() {
        let codegen = CodeGenerator::new(Target::X86_64);

        assert_eq!(codegen.type_size(&MirType::Unit), 0);
        assert_eq!(codegen.type_size(&MirType::Bool), 1);
        assert_eq!(codegen.type_size(&MirType::Int(32)), 4);
        assert_eq!(codegen.type_size(&MirType::Int(64)), 8);
        assert_eq!(codegen.type_size(&MirType::Ptr(Box::new(MirType::Int(32)))), 8);
    }
}
