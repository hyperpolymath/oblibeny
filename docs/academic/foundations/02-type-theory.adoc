// SPDX-License-Identifier: PMPL-1.0-or-later
// Copyright (c) 2024 Hyperpolymath

= Type-Theoretic Foundations for Oblivious Computing
:author: Oblibeny Project
:revdate: 2024
:toc: left
:toclevels: 4
:sectnums:
:stem: latexmath
:source-highlighter: rouge

== Abstract

This document presents the type-theoretic foundations for the Oblibeny ecosystem,
establishing a formal framework for reasoning about program correctness, memory
safety, and information flow in oblivious computing contexts. We develop a
type system that tracks access patterns at the type level, enabling static
verification of obliviousness properties.

== Preliminaries

=== Base Type System

We begin with a simply-typed lambda calculus extended with relevant constructs.

==== Syntax

.Types
[stem]
++++
\begin{aligned}
\tau ::=&\ \text{Unit} \mid \text{Bool} \mid \text{Int}_n \mid \text{Addr} \mid \text{Block} \\
      &\mid \tau_1 \to \tau_2 \mid \tau_1 \times \tau_2 \mid \tau_1 + \tau_2 \\
      &\mid \text{Array}[\tau, n] \mid \text{Ref}[\tau] \mid \forall \alpha. \tau
\end{aligned}
++++

.Terms
[stem]
++++
\begin{aligned}
e ::=&\ x \mid () \mid \text{true} \mid \text{false} \mid n \mid \lambda x:\tau. e \mid e_1\ e_2 \\
    &\mid (e_1, e_2) \mid \pi_1(e) \mid \pi_2(e) \mid \text{inl}(e) \mid \text{inr}(e) \\
    &\mid \text{case } e \text{ of inl}(x) \Rightarrow e_1 \mid \text{inr}(y) \Rightarrow e_2 \\
    &\mid \text{ref}(e) \mid !e \mid e_1 := e_2 \mid \text{read}(e) \mid \text{write}(e_1, e_2)
\end{aligned}
++++

=== Typing Judgments

The basic typing judgment is:

[stem]
++++
\Gamma \vdash e : \tau
++++

where stem:[\Gamma] is a typing context mapping variables to types.

== Information Flow Type System

=== Security Lattice

We employ a two-point security lattice:

[stem]
++++
L \sqsubseteq H
++++

where:
* stem:[L] = Low (public, observable by adversary)
* stem:[H] = High (secret, hidden from adversary)

=== Labeled Types

A *labeled type* is a pair stem:[\tau^{\ell}] where stem:[\tau] is a base type
and stem:[\ell \in \{L, H\}] is a security label.

[stem]
++++
\sigma ::= \tau^L \mid \tau^H
++++

=== Subtyping for Security

[stem]
++++
\frac{\tau_1 <: \tau_2 \quad \ell_1 \sqsubseteq \ell_2}{\tau_1^{\ell_1} <: \tau_2^{\ell_2}}
++++

This captures: data can flow from low to high, but not high to low.

=== Typing Rules for Information Flow

.T-VAR
[stem]
++++
\frac{(x : \sigma) \in \Gamma}{\Gamma \vdash x : \sigma}
++++

.T-ABS
[stem]
++++
\frac{\Gamma, x : \sigma_1 \vdash e : \sigma_2}{\Gamma \vdash \lambda x. e : (\sigma_1 \to \sigma_2)^L}
++++

.T-APP
[stem]
++++
\frac{\Gamma \vdash e_1 : (\sigma_1 \to \sigma_2)^\ell \quad \Gamma \vdash e_2 : \sigma_1}
     {\Gamma \vdash e_1\ e_2 : \sigma_2 \sqcup \ell}
++++

.T-IF (No Implicit Flow)
[stem]
++++
\frac{\Gamma \vdash e : \text{Bool}^L \quad \Gamma \vdash e_1 : \sigma \quad \Gamma \vdash e_2 : \sigma}
     {\Gamma \vdash \text{if } e \text{ then } e_1 \text{ else } e_2 : \sigma}
++++

=== Theorem: Noninterference

If stem:[\Gamma \vdash e : \tau^L] and stem:[e] is well-typed under the
information flow type system, then the final value of stem:[e] does not
depend on any inputs of type stem:[\tau'^H].

.Proof Sketch
====
By induction on the typing derivation. The key cases:

1. **Application**: If result is low, arguments influencing it must be low
2. **Conditionals**: Guard must be low for result to be low
3. **References**: Write targets inherit the label of written data

The formal proof uses a logical relations argument showing that high-equivalent
inputs produce low-equivalent outputs. ∎
====

== Oblivious Type System

=== Access Pattern Types

We extend the type system with *access pattern annotations*:

[stem]
++++
\sigma ::= \tau^{\ell, \pi}
++++

where stem:[\pi] is an access pattern descriptor:

* stem:[\text{Const}] - constant pattern (same addresses always)
* stem:[\text{Data}(x)] - pattern depends on data stem:[x]
* stem:[\text{Obliv}] - oblivious (indistinguishable patterns)

=== Oblivious Array Type

[stem]
++++
\text{OArray}[\tau, n] := \text{Array}[\tau, n]^{H, \text{Obliv}}
++++

An oblivious array has high-security content with oblivious access patterns.

=== Typing Rules for Oblivious Access

.T-OREAD
[stem]
++++
\frac{\Gamma \vdash a : \text{OArray}[\tau, n] \quad \Gamma \vdash i : \text{Int}^H}
     {\Gamma \vdash \text{oread}(a, i) : \tau^{H, \text{Obliv}}}
++++

.T-OWRITE
[stem]
++++
\frac{\Gamma \vdash a : \text{OArray}[\tau, n] \quad \Gamma \vdash i : \text{Int}^H \quad \Gamma \vdash v : \tau^H}
     {\Gamma \vdash \text{owrite}(a, i, v) : \text{Unit}^{L, \text{Obliv}}}
++++

=== Theorem: Access Pattern Obliviousness

If stem:[\Gamma \vdash e : \tau^{\ell, \text{Obliv}}], then the physical
memory access pattern of stem:[e] is independent of high-security inputs.

.Proof
====
By induction on typing derivations. The stem:[\text{Obliv}] annotation propagates
through operations, and primitive oblivious operations (oread, owrite) are
implemented using ORAM which provides access pattern indistinguishability by
construction. ∎
====

== Dependent Types for Size Bounds

=== Indexed Types

We use dependent types to track sizes statically:

[stem]
++++
\text{Vec} : \text{Type} \to \mathbb{N} \to \text{Type}
++++

=== Example: Path ORAM Tree Type

[stem]
++++
\begin{aligned}
\text{ORAMTree}(L) &: \text{Type} \\
\text{ORAMTree}(L) &= \text{Node} \times \text{Vec}[\text{ORAMTree}(L-1), 2] \\
\text{ORAMTree}(0) &= \text{Leaf}
\end{aligned}
++++

=== Theorem: Tree Height Preservation

All paths in stem:[\text{ORAMTree}(L)] have exactly stem:[L+1] nodes.

.Proof
====
By induction on stem:[L]:

**Base case** (stem:[L = 0]):
A stem:[\text{ORAMTree}(0)] is a single leaf, which has 1 node. stem:[0 + 1 = 1]. ✓

**Inductive case** (stem:[L = k + 1]):
A stem:[\text{ORAMTree}(k+1)] consists of a node with two children of type
stem:[\text{ORAMTree}(k)]. By IH, each child path has stem:[k + 1] nodes.
Adding the root gives stem:[(k + 1) + 1 = k + 2] nodes. ✓ ∎
====

== Linear Types for Resource Safety

=== Motivation

ORAM operations involve cryptographic state that must be used exactly once.
Linear types prevent:

1. Double-free of cryptographic contexts
2. Use of stale position maps
3. Forgetting to evict blocks

=== Linear Type Syntax

[stem]
++++
\sigma ::= \tau^\ell \mid \tau^! \mid \tau^?
++++

where:
* stem:[\tau^!] - must be used exactly once (linear)
* stem:[\tau^?] - may be used at most once (affine)

=== Linear Typing Rules

.T-LINEAR-VAR
[stem]
++++
\frac{}{x : \tau^! \vdash x : \tau}
++++

.T-LINEAR-APP
[stem]
++++
\frac{\Gamma_1 \vdash e_1 : (\sigma_1 \multimap \sigma_2) \quad \Gamma_2 \vdash e_2 : \sigma_1 \quad \Gamma_1 \cap \Gamma_2 = \emptyset}
     {\Gamma_1, \Gamma_2 \vdash e_1\ e_2 : \sigma_2}
++++

.T-ORAM-ACCESS
[stem]
++++
\frac{\Gamma \vdash s : \text{ORAMState}^! \quad \Gamma \vdash op : \text{Op}}
     {\Gamma \vdash \text{access}(s, op) : (\text{ORAMState}^! \times \text{Result})}
++++

=== Theorem: Linear Safety

Well-typed programs under the linear type system never:
1. Use an ORAM state after it has been consumed
2. Forget to properly finalize an ORAM state

.Proof
====
The linear typing rules ensure each linear resource is used exactly once.
The ORAM access operation consumes the old state and produces a new one,
threading the state linearly through computation. ∎
====

== Session Types for ORAM Protocols

=== Session Type Syntax

[stem]
++++
\begin{aligned}
S ::=&\ ![\tau].S \mid ?[\tau].S \mid S_1 \oplus S_2 \mid S_1 \mathop{\&} S_2 \\
    &\mid \mu X. S \mid X \mid \text{end}
\end{aligned}
++++

=== ORAM Client-Server Protocol

.Server Session Type
[stem]
++++
S_{\text{server}} = \mu X. ?\text{[Op]}. !\text{[Response]}. X
++++

.Client Session Type
[stem]
++++
S_{\text{client}} = \mu X. !\text{[Op]}. ?\text{[Response]}. X
++++

=== Theorem: Session Duality

stem:[S_{\text{client}}] and stem:[S_{\text{server}}] are dual session types:

[stem]
++++
S_{\text{client}} = \overline{S_{\text{server}}}
++++

This ensures deadlock-free communication.

.Proof
====
By coinduction on the recursive structure:
[stem]
++++
\overline{\mu X. ?[\tau].![\sigma].X} = \mu X. ![\tau].?[\sigma].X
++++
Duality swaps send (!) and receive (?). ∎
====

== Refinement Types for Bounds Checking

=== Refinement Type Syntax

[stem]
++++
\{x : \tau \mid \phi(x)\}
++++

where stem:[\phi] is a decidable predicate.

=== Example: Valid Block ID

[stem]
++++
\text{BlockID}(N) = \{i : \text{Int} \mid 0 \leq i < N\}
++++

=== Example: Valid Path

[stem]
++++
\text{ValidPath}(L) = \{p : \text{List}[\text{Node}] \mid |p| = L + 1 \land \text{isPath}(p)\}
++++

=== Theorem: Refinement Soundness

If stem:[\Gamma \vdash e : \{x : \tau \mid \phi(x)\}], then evaluating stem:[e]
yields a value satisfying stem:[\phi].

.Proof
====
By the semantics of refinement types, well-typed terms satisfy their refinements
at runtime. This is verified by SMT solver during type checking for decidable
predicates. ∎
====

== Effect System for Side Effects

=== Effect Annotations

[stem]
++++
\tau \xrightarrow{\varepsilon} \sigma
++++

where stem:[\varepsilon] is an effect set:

* stem:[\text{Read}(r)] - reads from region stem:[r]
* stem:[\text{Write}(r)] - writes to region stem:[r]
* stem:[\text{Alloc}(r)] - allocates in region stem:[r]
* stem:[\text{ORAM}] - performs ORAM operations
* stem:[\emptyset] - pure computation

=== Effect Typing Rules

.T-PURE
[stem]
++++
\frac{\Gamma \vdash e : \tau}{\Gamma \vdash e : \tau\ !\ \emptyset}
++++

.T-ORAM-EFFECT
[stem]
++++
\frac{\Gamma \vdash e_1 : \text{ORAMState} \quad \Gamma \vdash e_2 : \text{Op}}
     {\Gamma \vdash \text{access}(e_1, e_2) : \text{Result}\ !\ \{\text{ORAM}\}}
++++

=== Theorem: Effect Soundness

If stem:[\Gamma \vdash e : \tau\ !\ \varepsilon], then executing stem:[e]
produces only effects in stem:[\varepsilon].

== Type Safety Theorems

=== Theorem: Progress

If stem:[\cdot \vdash e : \tau], then either stem:[e] is a value or there
exists stem:[e'] such that stem:[e \to e'].

=== Theorem: Preservation

If stem:[\Gamma \vdash e : \tau] and stem:[e \to e'], then stem:[\Gamma \vdash e' : \tau].

=== Corollary: Type Safety

Well-typed programs don't get stuck.

.Proof
====
By induction on evaluation sequences, using Progress and Preservation. ∎
====

== Gradual Typing for Migration

=== Dynamic Type

[stem]
++++
\star ::= \text{Dyn}
++++

The dynamic type allows mixing typed and untyped code during migration.

=== Consistency Relation

[stem]
++++
\frac{}{\text{Dyn} \sim \tau} \quad \frac{}{\tau \sim \text{Dyn}} \quad \frac{}{\tau \sim \tau}
++++

=== Theorem: Gradual Guarantee

Adding type annotations to a well-typed program preserves behavior
(unless a cast fails at runtime).

== Conclusion

This type-theoretic foundation enables:

1. **Static verification** of information flow properties
2. **Compile-time checking** of obliviousness
3. **Resource safety** via linear types
4. **Protocol correctness** via session types
5. **Bounds safety** via refinement types

The type system serves as a specification language for the obli-transpiler-framework.

== References

1. Pierce, B. (2002). "Types and Programming Languages." MIT Press.
2. Sabelfeld, A. & Myers, A. (2003). "Language-Based Information-Flow Security." IEEE.
3. Walker, D. (2005). "Substructural Type Systems." ATTAPL.
4. Honda, K. et al. (2008). "Multiparty Asynchronous Session Types." POPL.

== TODO

// TODO: Implement type inference algorithm
// TODO: Add polymorphic effect types
// TODO: Formalize gradual typing semantics
// TODO: Add dependent session types for varying-size protocols
// TODO: Implement refinement type checking with SMT integration
