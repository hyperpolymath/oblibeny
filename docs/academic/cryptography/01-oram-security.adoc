// SPDX-License-Identifier: MIT OR Palimpsest-0.8
// Copyright (c) 2024 Hyperpolymath

= ORAM Security Proofs
:author: Oblibeny Project
:revdate: 2024
:toc: left
:toclevels: 4
:sectnums:
:stem: latexmath
:source-highlighter: rouge

== Abstract

This document provides complete security proofs for Oblivious RAM constructions
used in the Oblibeny ecosystem. We prove security under standard cryptographic
assumptions and analyze the bounds achieved.

== Security Model

=== Adversary Model

The adversary stem:[\mathcal{A}] is a probabilistic polynomial-time (PPT) algorithm
that:

1. Observes all physical memory accesses (addresses, not contents)
2. Knows the ORAM algorithm (Kerckhoffs' principle)
3. Does not know the secret key or randomness
4. Cannot modify memory (passive adversary)

=== Definition: ORAM Security

An ORAM scheme stem:[\mathcal{O} = (\text{Init}, \text{Access})] is *secure* if for
all PPT adversaries stem:[\mathcal{A}], all polynomial-length sequences of operations
stem:[\vec{y} = (op_1, \ldots, op_m)] and stem:[\vec{y}' = (op'_1, \ldots, op'_m)]:

[stem]
++++
\left| \Pr[\mathcal{A}(\text{AP}(\vec{y})) = 1] - \Pr[\mathcal{A}(\text{AP}(\vec{y}')) = 1] \right| \leq \text{negl}(\lambda)
++++

where stem:[\text{AP}(\cdot)] denotes the physical access pattern.

=== Simulation-Based Definition

Equivalently, there exists a simulator stem:[\mathcal{S}] such that:

[stem]
++++
\{\text{AP}(\vec{y})\}_{\vec{y}} \approx_c \{\mathcal{S}(1^\lambda, m)\}
++++

where stem:[m = |\vec{y}|] is the number of operations.

== Trivial ORAM

=== Construction

For each access, scan all stem:[N] blocks.

.Algorithm: TrivialORAM.Access
[source]
----
function Access(op, addr, data):
    for i = 1 to N:
        block = ReadBlock(i)
        if i == addr:
            if op == write:
                WriteBlock(i, data)
            result = block
        else:
            WriteBlock(i, block)  // dummy write
    return result
----

=== Theorem: Trivial ORAM Security

Trivial ORAM is perfectly secure (information-theoretically).

.Proof
====
Every access touches all stem:[N] blocks in the same order. The access pattern
is the constant sequence stem:[(1, 2, \ldots, N)] regardless of the operation.
Thus:
[stem]
++++
\text{AP}(\vec{y}) = \text{AP}(\vec{y}')
++++
for all stem:[\vec{y}, \vec{y}'], achieving perfect security. ∎
====

=== Complexity

* Bandwidth: stem:[O(N)] per access
* Client storage: stem:[O(1)]

== Square Root ORAM

=== Construction Overview

* Main memory: stem:[N] encrypted blocks
* Shelter: stem:[\sqrt{N}] slots for accessed items
* After stem:[\sqrt{N}] accesses, reshuffle

=== Theorem: Square Root ORAM Security

Square Root ORAM is computationally secure under IND-CPA encryption.

.Proof
====
**Game Sequence:**

*Game 0*: Real execution with access pattern stem:[\text{AP}(\vec{y})]

*Game 1*: Replace encryption with random strings
- Indistinguishable by IND-CPA security

*Game 2*: Access dummy locations in shelter when item found in shelter
- Physical pattern is now independent of logical pattern

**Hybrid Argument:**
[stem]
++++
|\Pr[G_0] - \Pr[G_2]| \leq \text{Adv}_{\text{IND-CPA}}(\mathcal{A}) + \text{negl}(\lambda)
++++

In Game 2, the access pattern depends only on:
1. Whether item is in shelter (random after reshuffle)
2. Order of dummy accesses (fixed)

Thus patterns are indistinguishable. ∎
====

=== Complexity

* Bandwidth: stem:[O(\sqrt{N})] amortized per access
* Client storage: stem:[O(\sqrt{N})]

== Path ORAM

=== Construction

**Data Structure:**
* Complete binary tree of height stem:[L = \lceil \log N \rceil]
* Each node contains a bucket of stem:[Z] blocks (typically stem:[Z = 4])
* Position map: stem:[\text{pos} : \text{BlockID} \to \text{Leaves}]
* Client stash for overflow

**Invariant:** Block stem:[b] with position stem:[\text{pos}(b) = \ell] is located
somewhere on the path from root to leaf stem:[\ell].

.Algorithm: PathORAM.Access
[source]
----
function Access(op, addr, data):
    // Remap block to new random leaf
    old_leaf = pos[addr]
    pos[addr] = RandomLeaf()

    // Read entire path to stash
    for node in Path(old_leaf):
        for block in Bucket[node]:
            Stash.add(block)

    // Update data if write
    if op == write:
        Stash[addr].data = data
    result = Stash[addr].data

    // Evict: write back as many blocks as possible
    for node in Path(old_leaf) from leaf to root:
        blocks_for_node = {b ∈ Stash : node ∈ Path(pos[b])}
        Bucket[node] = first Z blocks from blocks_for_node
        remove Bucket[node] from Stash

    return result
----

=== Theorem: Path ORAM Security

Path ORAM is computationally secure.

.Proof
====
We prove by showing the access pattern is simulatable.

**Simulator Construction:**
Given only stem:[m] (number of operations), stem:[\mathcal{S}] outputs:
1. For each operation: a uniformly random leaf stem:[\ell \xleftarrow{\$} [2^L]]
2. The access pattern: reading/writing all nodes on stem:[\text{Path}(\ell)]

**Indistinguishability:**

*Claim 1*: The sequence of accessed leaves is uniform random.

*Proof of Claim 1*: After each access, the accessed block gets a fresh random leaf.
The accessed leaf was assigned uniformly at random in a previous operation
(or initially). Thus each access touches a uniformly random path.

*Claim 2*: Physical accesses on each path are identical regardless of block locations.

*Proof of Claim 2*: Every access reads and writes all stem:[L+1] buckets on the path,
regardless of which blocks are present.

**Conclusion:**
[stem]
++++
\text{AP}(\vec{y}) \equiv \text{UniformPaths}(m)
++++

where stem:[\text{UniformPaths}(m)] is stem:[m] independent uniform random paths.
This is independent of stem:[\vec{y}], so:
[stem]
++++
\text{AP}(\vec{y}) \approx_c \text{AP}(\vec{y}')
++++
∎
====

=== Lemma: Stash Overflow Probability

For bucket size stem:[Z \geq 5] and any sequence of stem:[N] accesses:

[stem]
++++
\Pr[|\text{Stash}| > R] \leq 14 \cdot (0.6002)^R
++++

.Proof
====
The proof uses a careful analysis of the eviction process as a balls-into-bins game
with capacity constraints.

**Setup:**
- Model blocks as balls
- Buckets as bins with capacity stem:[Z]
- Each ball has a target leaf (uniformly random)

**Key Insight:**
A block at depth stem:[d] can potentially occupy any bucket on the path from
depth stem:[d] to the leaf. This flexibility enables efficient eviction.

**Analysis via Generating Functions:**
Let stem:[S] be the stash size. Define:
[stem]
++++
G(z) = \mathbb{E}[z^S] = \sum_{k=0}^{\infty} \Pr[S = k] z^k
++++

Through careful analysis of the eviction Markov chain:
[stem]
++++
G(z) \leq \frac{C}{1 - 0.6002z}
++++

for some constant stem:[C \leq 14].

Extracting tail bounds:
[stem]
++++
\Pr[S > R] = \Pr[z^S > z^R] \leq z^{-R} \mathbb{E}[z^S] = z^{-R} G(z)
++++

Setting stem:[z = 1/0.6002] gives the result. ∎
====

=== Corollary: Stash Size is stem:[O(\log \lambda)]

With overwhelming probability stem:[1 - \text{negl}(\lambda)]:

[stem]
++++
|\text{Stash}| \leq O(\lambda)
++++

Setting stem:[R = c \cdot \lambda] for appropriate constant stem:[c]:
[stem]
++++
\Pr[|\text{Stash}| > c\lambda] \leq 14 \cdot (0.6002)^{c\lambda} = \text{negl}(\lambda)
++++

=== Complexity Analysis

[cols="1,1"]
|===
| Metric | Value

| Bandwidth per access | stem:[O(\log N)] blocks = stem:[O(B \log N)] bits
| Client storage | stem:[O(\lambda)] blocks
| Server storage | stem:[O(N)] blocks (with constant factor stem:[\approx 2])
| Tree height | stem:[L = \lceil \log N \rceil]
|===

== Circuit ORAM

=== Motivation

Path ORAM's bandwidth is stem:[O(B \log N)] for block size stem:[B].
For small blocks (e.g., stem:[B = O(\log N)]), this is stem:[O(\log^2 N)].

Circuit ORAM achieves stem:[O(\log N)] for small blocks.

=== Construction Overview

* Uses tree structure like Path ORAM
* Eviction via "reverse lexicographic" order
* Deterministic eviction paths (no stash overflow)

=== Theorem: Circuit ORAM Security

Circuit ORAM is secure under the same conditions as Path ORAM.

.Proof Sketch
====
The proof follows similarly to Path ORAM:
1. Access patterns depend only on uniformly random leaves
2. Eviction pattern is deterministic and independent of data
3. Encryption hides block contents

The key difference is proving the eviction procedure maintains the invariant
without stash overflow, which requires careful combinatorial analysis. ∎
====

=== Complexity

[cols="1,2"]
|===
| Block size | Bandwidth per access

| stem:[B = \Omega(\log^2 N)] | stem:[O(B \log N)] (same as Path ORAM)
| stem:[B = O(\log N)] | stem:[O(\log^2 N)] (worse) vs stem:[O(\log N)] (Circuit)
|===

== Recursive ORAM

=== Position Map Challenge

Position map has stem:[N \cdot \log N] bits. Storing client-side is impractical.

=== Recursive Construction

1. Store position map in another (smaller) ORAM
2. Recursively until position map fits in client storage

.Recursive Structure
[stem]
++++
\mathcal{O}^{(0)} \xrightarrow{\text{pos map}} \mathcal{O}^{(1)} \xrightarrow{\text{pos map}} \cdots \xrightarrow{\text{pos map}} \mathcal{O}^{(D)}
++++

=== Theorem: Recursive ORAM Security

Recursive ORAM is secure if each constituent ORAM is secure.

.Proof
====
By hybrid argument over the recursion levels.

*Game stem:[i]*: Replace ORAMs stem:[\mathcal{O}^{(0)}, \ldots, \mathcal{O}^{(i-1)}] with
ideal (simulated) ORAMs.

*Game 0* = Real execution
*Game stem:[D+1]* = All ORAMs simulated (ideal)

By ORAM security of each level:
[stem]
++++
|\Pr[G_i] - \Pr[G_{i+1}]| \leq \text{negl}(\lambda)
++++

By union bound over stem:[D = O(\log N)] levels:
[stem]
++++
|\Pr[G_0] - \Pr[G_{D+1}]| \leq D \cdot \text{negl}(\lambda) = \text{negl}(\lambda)
++++
∎
====

=== Complexity

[cols="1,1"]
|===
| Metric | Value

| Bandwidth | stem:[O(\log^2 N)] without optimizations
| Client storage | stem:[O(1)] (constant)
| Recursion depth | stem:[D = O(\log N / \log \log N)]
|===

== Oblivious Transfer

=== 1-out-of-2 OT

**Functionality:** Sender has stem:[(m_0, m_1)], receiver has bit stem:[b].
Receiver learns stem:[m_b], sender learns nothing.

=== Definition: OT Security

An OT protocol stem:[\Pi = (S, R)] is secure if:

1. **Receiver security**: Sender cannot distinguish stem:[b = 0] from stem:[b = 1]
2. **Sender security**: Receiver learns nothing about stem:[m_{1-b}]

=== Theorem: OT from DDH

Under the Decisional Diffie-Hellman assumption, there exists a secure OT protocol.

.Construction (Naor-Pinkas)
====
**Setup:** Group stem:[\mathbb{G}] of prime order stem:[q], generator stem:[g].

**Protocol:**
1. Sender picks random stem:[a \xleftarrow{\$} \mathbb{Z}_q], sends stem:[A = g^a]
2. Receiver picks stem:[k \xleftarrow{\$} \mathbb{Z}_q]
   - If stem:[b = 0]: sends stem:[B_0 = g^k, B_1 = A/g^k]
   - If stem:[b = 1]: sends stem:[B_0 = A/g^k, B_1 = g^k]
3. Sender computes stem:[C_i = B_i^a] for stem:[i \in \{0, 1\}]
   - Sends stem:[E_i = m_i \oplus H(C_i)]
4. Receiver computes stem:[C_b = A^k = g^{ak}], decrypts stem:[m_b]
====

.Proof of Security
====
**Receiver security:**
stem:[B_0, B_1] are random group elements satisfying stem:[B_0 \cdot B_1 = A].
This distribution is independent of stem:[b].

**Sender security:**
stem:[C_{1-b} = (A/g^k)^a = g^{a(a-k)} = g^{a^2} / g^{ak}]

The receiver knows stem:[g^{ak}] but not stem:[g^{a^2}] (without knowing stem:[a]).
By DDH, stem:[(g, A, B_{1-b}, C_{1-b})] is indistinguishable from random. ∎
====

=== OT Extension

.Theorem (Ishai-Kilian-Nissim-Petrank)
From stem:[\kappa] base OTs, one can perform poly(stem:[\kappa])-many OTs
with only symmetric-key operations.

This is crucial for efficient ORAM constructions using OT.

== Security Composition

=== Universal Composability (UC)

The UC framework ensures security under arbitrary composition.

=== Definition: UC-Secure ORAM

An ORAM is UC-secure if it UC-realizes the ideal ORAM functionality stem:[\mathcal{F}_{\text{ORAM}}]:

.Ideal Functionality stem:[\mathcal{F}_{\text{ORAM}}]
[source]
----
On input (op, addr, data) from client:
    if op == read:
        return Memory[addr]
    else:  // write
        Memory[addr] = data
        return ack
----

No leakage to adversary except timing.

=== Theorem: Path ORAM is UC-Secure

In the stem:[\mathcal{F}_{\text{CPA}}]-hybrid model (ideal encryption),
Path ORAM UC-realizes stem:[\mathcal{F}_{\text{ORAM}}].

.Proof Sketch
====
The simulator:
1. On each access, simulates reading/writing a random path
2. Uses ideal encryption to hide block contents
3. Maintains consistent simulation of server storage

Indistinguishability follows from the standalone proof plus UC composition. ∎
====

== Lower Bounds

=== Theorem: Goldreich-Ostrovsky Lower Bound

Any ORAM with stem:[N] blocks must have bandwidth:

[stem]
++++
\Omega(\log N)
++++

per access (for statistical security).

.Proof Sketch
====
**Information-theoretic argument:**
Each access reveals one path in a tree of stem:[N] leaves.
To hide which of stem:[N] items is accessed, need stem:[\log N] bits of entropy
in the access pattern.

This entropy must come from randomness in the physical accesses,
requiring stem:[\Omega(\log N)] accesses. ∎
====

=== Theorem: Larsen-Nielsen Lower Bound

For ORAM with block size stem:[B]:

[stem]
++++
\text{Bandwidth} \geq \Omega\left(\frac{\log N}{\log(\log N / \log B)}\right) \cdot B
++++

This is tight for Path ORAM when stem:[B = \Omega(\log N)].

== Conclusion

The security of ORAM constructions rests on:

1. **Simulation paradigm**: Access patterns are simulatable
2. **Random remapping**: Blocks get fresh random positions
3. **Symmetric access**: All paths look identical
4. **Encryption**: Block contents are hidden

Path ORAM achieves optimal stem:[O(\log N)] bandwidth with small constant factors,
making it practical for the obli-fs implementation.

== References

1. Goldreich, O. & Ostrovsky, R. (1996). "Software Protection and Simulation on Oblivious RAMs." JACM.
2. Stefanov, E., et al. (2013). "Path ORAM: An Extremely Simple Oblivious RAM Protocol." CCS.
3. Wang, X., et al. (2015). "Circuit ORAM: On Tightness of the Goldreich-Ostrovsky Lower Bound." CCS.
4. Naor, M. & Pinkas, B. (1999). "Oblivious Transfer with Adaptive Queries." CRYPTO.
5. Larsen, K.G. & Nielsen, J.B. (2018). "Yes, There is an Oblivious RAM Lower Bound!" CRYPTO.

== TODO

// TODO: Add proofs for Ring ORAM
// TODO: Formalize concurrent ORAM security
// TODO: Add proofs for oblivious data structures (maps, stacks, queues)
// TODO: Prove security of write-only ORAM
// TODO: Add adaptive security proofs (adversary chooses operations online)
